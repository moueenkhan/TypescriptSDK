/**
 * Yapstone Staged On-Boarding ServicesLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ErrorsError } from '../errors/errorsError';
import {
  CreateInstrumentRequest,
  createInstrumentRequestSchema,
} from '../models/createInstrumentRequest';
import { Instrument, instrumentSchema } from '../models/instrument';
import { InstrumentPage, instrumentPageSchema } from '../models/instrumentPage';
import {
  UpdateInstrumentRequest,
  updateInstrumentRequestSchema,
} from '../models/updateInstrumentRequest';
import {
  VerifyInstrumentRequest,
  verifyInstrumentRequestSchema,
} from '../models/verifyInstrumentRequest';
import { boolean, number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class InstrumentsController extends BaseController {
  /**
   * Retrieve all Instruments.
   *
   * @param offset              Offset the list of returned results by this amount. Default is `0`.
   * @param limit               Number of items to retrieve.
   * @param marketplaceId       Filter by `marketplaceId`.
   * @param merchantId          Filter by `merchantId`.
   * @param customerId          Filter by `customerId`.
   * @param correlationRefLabel Filter by `correlationRef.label`.
   * @param correlationRefValue Filter by `correlationRef.value`.
   * @param internalUseOnly     Indicates that internal-use-only fields should be returned.
   * @return Response from the API call
   */
  async getInstruments(
    offset?: number,
    limit?: number,
    marketplaceId?: string,
    merchantId?: string,
    customerId?: string,
    correlationRefLabel?: string,
    correlationRefValue?: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<InstrumentPage>> {
    const req = this.createRequest('GET', '/instruments');
    const mapped = req.prepareArgs({
      offset: [offset, optional(number())],
      limit: [limit, optional(number())],
      marketplaceId: [marketplaceId, optional(string())],
      merchantId: [merchantId, optional(string())],
      customerId: [customerId, optional(string())],
      correlationRefLabel: [correlationRefLabel, optional(string())],
      correlationRefValue: [correlationRefValue, optional(string())],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.query('offset', mapped.offset);
    req.query('limit', mapped.limit);
    req.query('marketplaceId', mapped.marketplaceId);
    req.query('merchantId', mapped.merchantId);
    req.query('customerId', mapped.customerId);
    req.query('correlationRefLabel', mapped.correlationRefLabel);
    req.query('correlationRefValue', mapped.correlationRefValue);
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.throwOn(400, ErrorsError, 'Bad Request');
    return req.callAsJson(instrumentPageSchema, requestOptions);
  }

  /**
   * Create an Instrument.
   *
   * @param request
   * @param xYapStoneIdempotentKey
   * @param internalUseOnly          Indicates that internal-use-only fields should
   *                                                                   be returned.
   * @return Response from the API call
   */
  async createInstrument(
    request: CreateInstrumentRequest,
    xYapStoneIdempotentKey?: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Instrument>> {
    const req = this.createRequest('POST', '/instruments');
    const mapped = req.prepareArgs({
      request: [request, createInstrumentRequestSchema],
      xYapStoneIdempotentKey: [xYapStoneIdempotentKey, optional(string())],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.header('X-YapStone-IdempotentKey', mapped.xYapStoneIdempotentKey);
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.json(mapped.request);
    req.throwOn(409, ErrorsError, 'Conflict');
    req.throwOn(422, ErrorsError, 'Unprocessable Entity');
    return req.callAsJson(instrumentSchema, requestOptions);
  }

  /**
   * Retrieve an Instrument by id.
   *
   * @param id
   * @param internalUseOnly Indicates that internal-use-only fields should be returned.
   * @return Response from the API call
   */
  async getInstrument(
    id: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Instrument>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      id: [id, string()],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.appendTemplatePath`/instruments/${mapped.id}`;
    req.throwOn(404, ErrorsError, 'Not Found');
    return req.callAsJson(instrumentSchema, requestOptions);
  }

  /**
   * Update an Instrument by id.
   *
   * @param id
   * @param request
   * @param xYapStoneIdempotentKey
   * @param internalUseOnly          Indicates that internal-use-only fields should
   *                                                                   be returned.
   * @return Response from the API call
   */
  async updateInstrument(
    id: string,
    request: UpdateInstrumentRequest,
    xYapStoneIdempotentKey?: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Instrument>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      request: [request, updateInstrumentRequestSchema],
      xYapStoneIdempotentKey: [xYapStoneIdempotentKey, optional(string())],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.header('X-YapStone-IdempotentKey', mapped.xYapStoneIdempotentKey);
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.json(mapped.request);
    req.appendTemplatePath`/instruments/${mapped.id}`;
    req.throwOn(404, ErrorsError, 'Not Found');
    req.throwOn(409, ErrorsError, 'Conflict');
    req.throwOn(422, ErrorsError, 'Unprocessable Entity');
    return req.callAsJson(instrumentSchema, requestOptions);
  }

  /**
   * Delete an Instrument by id.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteInstrument(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Instrument>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/instruments/${mapped.id}`;
    req.throwOn(404, ErrorsError, 'Not Found');
    return req.callAsJson(instrumentSchema, requestOptions);
  }

  /**
   * Request verification of an Instrument by id.
   *
   * @param id
   * @param request
   * @return Response from the API call
   */
  async verifyInstrument(
    id: string,
    request: VerifyInstrumentRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Instrument>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({
      id: [id, string()],
      request: [request, verifyInstrumentRequestSchema],
    });
    req.json(mapped.request);
    req.appendTemplatePath`/instruments/${mapped.id}/verification`;
    req.throwOn(404, ErrorsError, 'Not Found');
    return req.callAsJson(instrumentSchema, requestOptions);
  }
}
