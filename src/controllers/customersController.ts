/**
 * Yapstone Staged On-Boarding ServicesLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import { ErrorsError } from '../errors/errorsError';
import {
  CreateCustomerRequest,
  createCustomerRequestSchema,
} from '../models/createCustomerRequest';
import { Customer, customerSchema } from '../models/customer';
import { CustomerPage, customerPageSchema } from '../models/customerPage';
import {
  UpdateCustomerRequest,
  updateCustomerRequestSchema,
} from '../models/updateCustomerRequest';
import { boolean, number, optional, string } from '../schema';
import { BaseController } from './baseController';

export class CustomersController extends BaseController {
  /**
   * Retrieve all Customers.
   *
   * @param offset              Offset the list of returned results by this amount. Default is `0`.
   * @param limit               Number of items to retrieve.
   * @param correlationRefLabel Filter by `correlationRef.label`.
   * @param correlationRefValue Filter by `correlationRef.value`.
   * @param marketplaceId       Filter by `marketplaceId`.
   * @param merchantId          Filter by `merchantId`.
   * @param internalUseOnly     Indicates that internal-use-only fields should be returned.
   * @return Response from the API call
   */
  async getCustomers(
    offset?: number,
    limit?: number,
    correlationRefLabel?: string,
    correlationRefValue?: string,
    marketplaceId?: string,
    merchantId?: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<CustomerPage>> {
    const req = this.createRequest('GET', '/customers');
    const mapped = req.prepareArgs({
      offset: [offset, optional(number())],
      limit: [limit, optional(number())],
      correlationRefLabel: [correlationRefLabel, optional(string())],
      correlationRefValue: [correlationRefValue, optional(string())],
      marketplaceId: [marketplaceId, optional(string())],
      merchantId: [merchantId, optional(string())],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.query('offset', mapped.offset);
    req.query('limit', mapped.limit);
    req.query('correlationRefLabel', mapped.correlationRefLabel);
    req.query('correlationRefValue', mapped.correlationRefValue);
    req.query('marketplaceId', mapped.marketplaceId);
    req.query('merchantId', mapped.merchantId);
    req.query('internalUseOnly', mapped.internalUseOnly);
    return req.callAsJson(customerPageSchema, requestOptions);
  }

  /**
   * Create a Customer.
   *
   * @param request
   * @param xYapStoneIdempotentKey
   * @param internalUseOnly          Indicates that internal-use-only fields should be
   *                                                                 returned.
   * @return Response from the API call
   */
  async createCustomer(
    request: CreateCustomerRequest,
    xYapStoneIdempotentKey?: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Customer>> {
    const req = this.createRequest('POST', '/customers');
    const mapped = req.prepareArgs({
      request: [request, createCustomerRequestSchema],
      xYapStoneIdempotentKey: [xYapStoneIdempotentKey, optional(string())],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.header('X-YapStone-IdempotentKey', mapped.xYapStoneIdempotentKey);
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.json(mapped.request);
    req.throwOn(409, ErrorsError, 'Conflict');
    req.throwOn(422, ErrorsError, 'Unprocessable Entity');
    return req.callAsJson(customerSchema, requestOptions);
  }

  /**
   * Retrieve a Customer by id.
   *
   * @param id
   * @param internalUseOnly Indicates that internal-use-only fields should be returned.
   * @return Response from the API call
   */
  async getCustomer(
    id: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Customer>> {
    const req = this.createRequest('GET');
    const mapped = req.prepareArgs({
      id: [id, string()],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.appendTemplatePath`/customers/${mapped.id}`;
    req.throwOn(404, ErrorsError, 'Not Found');
    return req.callAsJson(customerSchema, requestOptions);
  }

  /**
   * Update a Customer by id.
   *
   * @param id
   * @param request
   * @param xYapStoneIdempotentKey
   * @param internalUseOnly          Indicates that internal-use-only fields should be
   *                                                                 returned.
   * @return Response from the API call
   */
  async updateCustomer(
    id: string,
    request: UpdateCustomerRequest,
    xYapStoneIdempotentKey?: string,
    internalUseOnly?: boolean,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Customer>> {
    const req = this.createRequest('PUT');
    const mapped = req.prepareArgs({
      id: [id, string()],
      request: [request, updateCustomerRequestSchema],
      xYapStoneIdempotentKey: [xYapStoneIdempotentKey, optional(string())],
      internalUseOnly: [internalUseOnly, optional(boolean())],
    });
    req.header('X-YapStone-IdempotentKey', mapped.xYapStoneIdempotentKey);
    req.query('internalUseOnly', mapped.internalUseOnly);
    req.json(mapped.request);
    req.appendTemplatePath`/customers/${mapped.id}`;
    req.throwOn(404, ErrorsError, 'Not Found');
    req.throwOn(409, ErrorsError, 'Conflict');
    req.throwOn(422, ErrorsError, 'Unprocessable Entity');
    return req.callAsJson(customerSchema, requestOptions);
  }

  /**
   * Delete a Customer by id.
   *
   * @param id
   * @return Response from the API call
   */
  async deleteCustomer(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Customer>> {
    const req = this.createRequest('DELETE');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/customers/${mapped.id}`;
    req.throwOn(404, ErrorsError, 'Not Found');
    return req.callAsJson(customerSchema, requestOptions);
  }

  /**
   * Perform verification of a Customers supplied details.
   *
   * @param id
   * @return Response from the API call
   */
  async verifyCustomer(
    id: string,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<Customer>> {
    const req = this.createRequest('POST');
    const mapped = req.prepareArgs({ id: [id, string()] });
    req.appendTemplatePath`/customers/${mapped.id}/verification`;
    return req.callAsJson(customerSchema, requestOptions);
  }
}
